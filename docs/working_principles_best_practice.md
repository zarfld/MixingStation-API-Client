The following list is derived from the sources, categorized into mandatory actions ("Always Do") and strictly discouraged actions ("Never Do"), particularly reflecting the principles of Extreme Programming (XP), Test-Driven Development (TDD), and Object-Oriented Design (OOD). *** ## 1. Always Do (Absolute Positive / Must) This list contains practices and rules described in the sources as mandatory, essential, or strongly recommended. | Instruction (Always Do / Must) | Details and Rationale (Sources) | | :--- | :--- | | **Test Before Coding (TDD)** | **Write a failing automated test before you write any code** [1-5]. | | **Eliminate Duplication (DRY)** | **Eliminate duplication** [3, 4, 6, 7]. Ensure every piece of knowledge has a **single, unambiguous, authoritative representation** [8]. Say everything **once and only once** [7, 9]. | | **Refactor Continuously** | **Refactor early, refactor often** [10]. Refactoring is a **daily recurring activity** [6, 11]. Restructure the system **without changing its behavior** [2, 6]. | | **Run All Tests Flawlessly** | **All tests must run flawlessly** for development to continue [12-15]. Ensure the system **always works**, using comprehensive unit and acceptance tests [16]. | | **Test Thoroughly** | **Test everything that could possibly break** [16, 17]. Write tests for any non-trivial object (that has behavior) [17]. | | **Automate Acceptance Tests** | Customer acceptance tests **must be automated** [18-20]. | | **Integrate Continuously (CI)** | **Integrate and build the system many times a day** [1, 6, 21]. No code should sit unintegrated for **more than a couple of hours** [13, 22]. | | **Practice Pair Programming** | **Write all production code in pairs** [6, 16, 23]. | | **Strive for Simplicity** | **Assume simplicity** [24, 25]. Make the design of the system **as simple as possible at any given moment** (Simple Design) [12, 26-28]. | | **Design Incrementally** | **Invest in the design of the system every day** [27]. Design should be gradual but persistent [27]. | | **Take Small Steps** | **Always take small, deliberate steps**, checking for feedback before proceeding [29, 30]. | | **Deliver Frequently** | Put a simple system into production quickly, then release **new versions on a very short cycle (Small releases)** [12, 31, 32]. | | **Use Domain Vocabulary** | Use a versatile, shared team language (the **Ubiquitous Language**) [33-36]. **Maintain a project glossary** [37, 38]. | | **Adhere to OOD Principles** | **Depend upon abstractions**. Do not depend upon concrete classes [39-44]. Favor **composition over inheritance** [42, 44-46]. | | **Follow the Open/Closed Principle (OCP)** | Classes should be **open for extension but closed for modification** [40, 42, 44, 45]. | | **Follow the Single Responsibility Principle (SRP)** | A class should have **only one reason to change** [43, 44, 47-49]. | | **Encapsulate Variation** | **Encapsulate what varies** [42-44]. | | **Strive for Loose Coupling** | **Strive for loosely coupled designs** between interacting objects [42, 44, 47, 50, 51]. | | **Use Side-Effect-Free Functions** | Place logic in **functions that do not produce any abstract side effect** [52, 53]. | | **Automate Operations** | **Automate** operational procedures to minimize risk of anomalies [54]. **Automate everything** [55]. | | **Apply Security Patches Quickly** | **Apply security patches quickly** to avoid vulnerability to known exploits [56]. | | **Communicate Clearly** | Focus on **open, honest communication** [57, 58]. Conversation is the preferred form of communication [59]. | | **Use Assertions/Prove Assumptions** | **Use assertions to prevent the impossible** [60]. **Don’t assume it—prove it** [61]. Test your assumptions [62]. | | **Use Active Voice in Requirements** | Write requirements using the **active voice** (e.g., "The actor does X"), not the passive voice [63, 64]. | | **Maintain Only Code and Tests** | **Maintain only the code and the tests as permanent artifacts** [65]. Documents should **stay current** [66]. | ## 2. Never Do (Absolute Negative / Avoid) This list details practices and anti-patterns that developers should avoid because they introduce complexity, coupling, or risk. | Instruction (Never Do / Avoid) | Details and Rationale (Sources) | | :--- | :--- | | **Avoid Gold Plating/Building for Tomorrow** | **Don't build for tomorrow** [67-70]. Implement only what is necessary for the **current system needs** [67-69]. | | **Avoid Train Wrecks** | **Don’t chain method calls** [71, 72]. Try not to have **more than one “.”** when accessing something (violation of the Principle of Least Knowledge) [72]. | | **Avoid Premature Architecture/Design** | **Don't try to design the whole system** before starting implementation [73]. **Don't try to freeze requirements** before starting implementation [74]. | | **Avoid Excessive Documentation** | **Don't produce voluminous design documents** at the beginning or middle [75]. **Don't produce documents or artifacts that aren't being used** [76]. | | **Avoid Skipping Tests** | **Never let the press of time urge you to skip the tests** [20]. "Test Later" really means **"Test Never"** [77, 78]. | | **Avoid Global State** | **Avoid global data**, including Singletons used as global variables [79]. Singletons create a central state point that can lead to bugs [79]. | | **Avoid Forced Design Patterns** | Let patterns **emerge**; **don't force them** in just for the sake of using a pattern [80-82]. Always go with the **simplest solution** that does the job [83, 84]. | | **Avoid Direct Dependency Instantiation (DI)** | Do not instantiate dependencies directly inside the class (This is the **Control Freak anti-pattern**) [85, 86]. | | **Avoid Service Locator** | Avoid the **Service Locator anti-pattern**, as it nullifies the advantages of Dependency Injection [87, 88]. | | **Avoid Centralized Control (Microservices)** | **Prefer choreography over orchestration** [89]. Avoid architectures that lead to the **centralization of business logic** [89]. | | **Avoid Database Integration** | **Avoid database integration at all costs** (because it creates tight coupling) [89, 90]. | | **Avoid Exposing Internal Details** | Avoid technologies that force you to **expose internal representation details**, as this increases coupling [91]. | | **Be Relaxed About DRY Across Services** | Do not overemphasize DRY across service boundaries using shared libraries, as this leads to **tight coupling** [92, 93]. | | **Avoid Broken Windows** | **Do not live with "broken windows"** (poor designs, incorrect decisions, bad code) [94]. | | **Avoid Lame Excuses** | **Provide options, don’t make lame excuses** [95]. | | **Avoid Team Specialization** | **Don't separate the team into designers and coders** [96]. Let everyone be involved in design [96]. | | **Avoid Functionally Decomposing Use Cases** | Do not functionally decompose use cases into smaller and smaller pieces using «include» or «extend» [97, 98]. | | **Avoid Ambiguous Language** | **Avoid vague and general terms** (superlatives, subjective language, ambiguous pronouns/adverbs) [63]. | | **Avoid Negative Requirements** | Do not use negative requirements like **“shall not”** [63]. | | **Avoid On Autopilot** | **Never run on auto-pilot**; constantly think about your work [99]. | | **Avoid Testing Others' Code** | Do **not test code from others** (unless you have reason to distrust it) [100]. | | **Avoid Storing Secrets in Source Code** | **Don’t check in secrets, API keys, or credentials** alongside your source code in version control [101]. | | **Avoid Overly Strict Password Rules** | **Do not enforce arbitrary composition rules** for passwords, or restrict their length unnecessarily (e.g., less than 64 characters) [101]. |



The following instruction template for a Copilot draws upon best practices from the principles of Verification and Validation (V&V) [1], Extreme Programming (XP) [2], and fundamental object-oriented design principles [3]. ## **Copilot Instruction Template: Software Development Best Practices** ### **1. General Principles & Development Philosophy** | DOs (Mandatory Requirements) | DON’Ts (Practices to Avoid) | | :--- | :--- | | **Embrace Change** [4, 5] and operate under the principle that requirements, design, and technology are constantly changing [4]. | Avoid developing or designing for the future (e.g., "Don't build for tomorrow") based on hypothetical needs; implement the simplest thing that solves **today’s** problem well [6, 7]. | | Prioritize **communication**; conversation is the most effective method, especially for complex decisions [8, 9]. | Do not run on auto-pilot; constantly **think** and critically appraise every decision made [10]. | | Focus on maximizing **simplicity** and the amount of work not done [11, 12]. | Do not ignore defects or quality issues (**"No Broken Windows"**) [13, 14]; address small imperfections immediately [14]. | | Deliver working software frequently (e.g., weeks or months, preferably shorter timeframes) [15]. | Do not become attached to your own ideas; be prepared to replace them as deeper insights emerge through experience [16, 17]. | | Use experience and feedback to drive the design process; focus on **"design always"** rather than comprehensive upfront design ("Big Design Up Front") [18, 19]. | Do not use design patterns or complexity where they are not needed; always favor the simplest solution that meets the requirement [20-23]. | | Ensure **Quality** is paramount; quality must be "excellent" [14, 24]. | Do not produce documents or other artifacts that are not actively being used or referenced by the team [25]. | ### **2. Requirements Engineering (Stakeholder Needs & Definition V&V)** | DOs (Mandatory Requirements) | DON’Ts (Practices to Avoid) | | :--- | :--- | | Requirements must be **necessary, appropriate, unambiguous, complete, singular, feasible, verifiable, and correct** (well-formed characteristics) [26-30]. | Avoid using **vague or general terms** (e.g., superlatives like 'best', subjective language like 'user friendly', ambiguous logical statements like 'and/or') [31-33]. | | Use the word "**shall**" for mandatory binding provisions [34, 35]. Use "should" for desired but non-mandatory goals [36]. | Avoid using the term "**must**" due to its potential for misinterpretation as a requirement [34]. | | Requirements must specify **what** is needed for the system-of-interest, not **how** the solution should be designed or implemented (avoid unnecessary constraints on the design) [37-39]. | Avoid using **loopholes** (such as 'if possible', 'as appropriate', 'as applicable') [32, 33]. | | Requirements shall be **traceable** to one or more stakeholders and their needs [40-42]. | Do not write requirements that are **only valued by developers** (e.g., dictating the use of specific infrastructure technology like a connection pool) [43]. | | Use objective acceptance criteria to make requirements **verifiable** and **testable** [41, 44, 45]. | Do not wait for requirements to be "finished" before starting design; recognize that requirements are constantly in flux [19, 46]. | | Document constraints (e.g., budget, technical limitations, compliance with regulations, physical laws, and business rules) [47-51]. | Avoid using **negative requirements** (e.g., 'shall not') [36]. | ### **3. Architecture Definition** | DOs (Mandatory Requirements) | DON’Ts (Practices to Avoid) | | :--- | :--- | | Base the architecture on a prioritized list of **well-specified Quality Attribute Requirements (QAs)** [52, 53]. | Do not confuse architecture with detailed design; architecture leaves many decisions unbound, relying on the discretion of implementers [54]. | | Ensure the architecture has **Conceptual Integrity** (consistency in design); the same things should be done in the same way throughout the architecture (e.g., error handling, logging, component interaction) [55, 56]. | Avoid relying on specific versions of commercial products or tools; design should facilitate straightforward replacement [57]. | | Design structures using the principles of **Information Hiding** and **Separation of Concerns** [58, 59]. Modules should encapsulate aspects likely to change [58]. | Do not establish an isolated "ivory tower" architecture; architects must actively engage with development teams to ensure practical designs and live with the consequences of their decisions [60, 61]. | | Document architectural decisions using **Views** (representations addressing stakeholder concerns) [52, 62]. Views should include composition, refinement, and traceability relations [63]. | Do not adopt solutions without testing them; rely on concrete experiments and prototypes to validate architectural choices [64, 65]. | | Define the architecture to adhere to organizational design guidance, principles, and tenets (e.g., service-oriented architecture) [66, 67]. | Do not overspecify the design upfront; only include enough detail to satisfy the current requirements (Simple Design) [68, 69]. | ### **4. Design (Detailed/Tactical)** | DOs (Mandatory Requirements) | DON’Ts (Practices to Avoid) | | :--- | :--- | | Implement the **simplest design that could possibly work** [6, 20, 70-72]. | Avoid duplicated logic; enforce the **DRY (Don’t Repeat Yourself) Principle**. Duplication signals a lurking idea or concept that needs to be abstracted [68, 73, 74]. | | Design entities should obey the **Open-Closed Principle**: open for extension, but closed for modification [75-77]. | Do not violate the **Principle of Least Knowledge** (Only talk to your friends); avoid method chaining (e.g., using more than one dot in an access chain) [78]. | | Design elements should adhere to the **Single Responsibility Principle** (A class should have only one reason to change) [79, 80]. | Do not add flexibility or abstraction unless it is supported by a demonstrable, practical need today [6, 81]. | | Favor **composition over inheritance** [3, 77, 82]. | Avoid design solutions solely based on technical virtuosity or without convincing domain expert validation [83]. | | Program to **interfaces**, not implementations [3, 77, 82]. Depend on **abstractions** [79]. | Do not attempt to design the entire system before implementing [84]. | | Let design **patterns emerge naturally** when necessary (e.g., to encapsulate change or simplify) [21, 85]. | Avoid having two elements with identical or very similar responsibilities [86]. | ### **5. Coding / Implementation** | DOs (Mandatory Requirements) | DON’Ts (Practices to Avoid) | | :--- | :--- | | Write all production code using **Pair Programming** [87-89]. | Do not program by **coincidence**; always program deliberately, documenting assumptions and proving them [90, 91]. | | Practice **Continuous Integration**; integrate and build the system multiple times a day, ideally whenever a task is completed [89, 92]. | Do not leave code unintegrated for longer than a few hours [89, 93]. | | Adopt **Collective Code Ownership**; anyone can change any code anywhere to fix or improve it [89, 94]. | Avoid writing comments that merely paraphrase the code [95, 96]. | | Adhere strictly to agreed-upon **Coding Standards** for naming, indentation, and formatting to emphasize **communication through code** [97-99]. | Do not assume an error cannot happen; analyze all errors and record discrepancies between actual and expected results [100-102]. | | Write **intention-revealing code**; use comments sparsely, primarily to explain **why** something is done, not **how** [96, 103]. | Do not catch or re-raise exceptions unless absolutely necessary (Catch and Release is for fish); avoid increasing coupling by listing specific exceptions [100, 104]. | | Use **Assertions** (preconditions, postconditions, invariants) to document interfaces and verify internal consistency (Design by Contract) [105-109]. | ### **6. Testing and V&V (Verification & Validation)** | DOs (Mandatory Requirements) | DON’Ts (Practices to Avoid) | | :--- | :--- | | Practice **Test-Driven Development (TDD)** using the cycle: **Red $\to$ Green $\to$ Refactor** [110-112]. | **Never write new functionality without a failing test** [92, 112, 113]. | | Maintain **comprehensive unit tests** (written by the developer) and **acceptance tests** (written by or with the customer) [88, 114, 115]. | Do not ignore the signal of difficult-to-test code; **difficulty writing a test often indicates a design problem** (low cohesion, high coupling) [116, 117]. | | Ensure that **all tests run** successfully before checking in or integrating code [114, 118, 119]. | Do not perform V&V only at the conclusion of phases; V&V processes must be performed **in parallel** with all life cycle stages [120-122]. | | The Verification process must provide objective evidence that products **conform to requirements** (correctness, completeness, consistency, accuracy) [51, 123-125]. | Do not rely on unreliable conditions in tests, such as exact timestamps, specific error wording, or non-orthogonal widget positions [126]. | | The Validation process must provide evidence that products **satisfy intended use and user needs** (solve the right problem) [121, 125, 127, 128]. | Do not immediately promote prototypes to production code without careful validation, as this risks deploying disposable, incomplete code [129, 130]. | | Use testing to cover scenarios, stress/boundary conditions, and fault recovery, especially for high-integrity level systems [131-134]. | | ### **7. Documentation** | DOs (Mandatory Requirements) | DON’Ts (Practices to Avoid) | | :--- | :--- | | Treat documentation as an **essential, albeit secondary, product** of the development process [135, 136]. | Do not allow the production of documentation to drive the development process [135, 137]. | | **Build documentation in, don’t bolt it on** [96]. Integrate documentation directly into the code (e.g., API comments) [96, 138]. | Avoid producing bulky design documents upfront; they quickly become outdated [139, 140]. | | Document the **Rationale** (explanation, justification, and alternatives considered) for key architectural decisions [63, 141, 142]. | Do not create documents that merely paraphrase the code (violates DRY); instead, document the high-level intent or the "why" [95, 96]. | | Ensure documentation evolves iteratively with the system (documentation is a "living product") [135, 143]. | Do not omit required V&V documentation elements such as test plans, designs, cases, procedures, and results [144, 145]. | | Define and use a **Ubiquitous Language** (shared team language) in conversations, documents, and code to ensure model integrity and clarity [143, 146, 147]. | Do not allow the language in documents to diverge from the language used in conversation and code [143]. | | Document the **high-level system architecture**, **key abstractions**, and **mechanisms** [148, 149]. | Do not write documentation in a way that is confusing or boring to the target audience (e.g., clients typically skip technical requirement documents) [150]. |

Die Abkürzung **DRY** steht für **"Don’t Repeat Yourself"** (Wiederhole dich nicht) [1, 2]. Es ist eine der wichtigsten Heuristiken im Design [3-6]. ### **Kernkonzept und Ziel** Das Prinzip geht über die bloße Vermeidung doppelter Codezeilen hinaus [7]. DRY bedeutet genauer, dass die **Duplizierung von Systemverhalten und Wissen** vermieden werden soll [1, 8]. Die zentrale Regel lautet: **Jedes Wissenselement** (data, structure, or logic) muss eine **einzige, eindeutige, autoritative Repräsentation** innerhalb eines Systems haben [2, 3]. Die Einhaltung von DRY wird durch **Refactoring** erreicht, indem duplizierte Logik oder Code in **Abstraktionen** (wie Methoden oder Objekte) zusammengefasst werden, die dann von mehreren Stellen aufgerufen werden können [9-12]. Die Entfernung von Duplizierung ist ein Kernbestandteil des Test-Driven Development (TDD) Zyklus [13-15]. ### **Gründe für die Vermeidung von Duplizierung** Duplizierung wird als ein **Symptom** von Abhängigkeit betrachtet [16]. Wenn Code dupliziert ist, führt dies zu folgenden Problemen: 1. **Fehleranfälligkeit:** Wenn eine konzeptionelle Änderung erforderlich ist, muss diese an **mehreren Stellen** vorgenommen werden [1, 3]. Es ist leicht, eine dieser redundanten Kopien zu vergessen, was zu **Widersprüchen** und Fehlern (**bugs**) führt [2, 9]. 2. **Wartungskosten:** Code ohne Duplizierung hat die Eigenschaft, dass eine konzeptionelle Änderung nur eine Codeänderung erfordert, wodurch nachfolgende Änderungen **kostengünstig** bleiben [3]. 3. **Designqualität:** Wenn keine Duplizierung vorliegt, ist das zu ändernde Element in nur **einer Stelle** isoliert, was Änderungen erleichtert [17]. Duplizierung deutet oft auf eine **versteckte Idee** hin, die abstrahiert werden muss [9]. ### **Anwendungsbereiche und Abgrenzung** Das DRY-Prinzip gilt nicht nur für Code [7], sondern auch für: * **Daten und Wissen:** Beim Speichern von Daten sollte human-sinnvolle Information nur an einer Stelle gespeichert werden (z. B. die Verwendung von IDs anstelle von Textkopien), um Konsistenz zu gewährleisten, falls sich diese Information ändert [18]. Die Entfernung von Duplizierung ist der **Schlüssel zur Normalisierung** in Datenbanken [18]. * **Dokumentation:** Das Schreiben von Kommentaren, die lediglich paraphrasieren, *wie* der Code funktioniert, ist redundant und stellt eine Verletzung des DRY-Prinzips dar; Kommentare sollten sich stattdessen darauf konzentrieren, **warum** etwas getan wird [19]. * **Tests:** Die Duplizierung von Informationen zwischen Testcode und Produktionscode verletzt DRY [20]. Ebenso verstößt die Benennung von Unit Tests nach der Methode (z. B. isReady()) gegen DRY, da diese Information bereits in der Zielklasse ausgedrückt wird [21]. #### **Wissen vs. Zufall (Coincidence)** Nicht jede Code-Duplizierung ist eine Verletzung von DRY [22]. Wenn zwei Codeteile zufällig gleich sind, aber **unterschiedliches Wissen** repräsentieren (z. B. separate Validierungen für das Alter und die Menge, die zufällig dieselben Regeln befolgen), handelt es sich um eine **Koinzidenz**, nicht um eine Duplizierung des Wissens. Eine Verletzung liegt nur vor, wenn eine Änderung in einem Bereich eine Änderung in beiden Codeteilen erforderlich macht [8, 23]. #### **DRY in Microservices (Wichtiges Gegenbeispiel)** In Microservice-Architekturen ist besondere Vorsicht geboten: * Man sollte **DRY innerhalb eines Microservice** konsequent einhalten [24]. * Man sollte jedoch die **Verletzung von DRY über alle Dienste hinweg gelassener** sehen [24]. * Die Verwendung von gemeinsam genutztem Code oder Bibliotheken (wie gemeinsamen Domänenobjekten) zwischen Microservices kann zu einer **übermäßigen Kopplung** (*coupling*) führen, was die **Kosten für Änderungen erhöht** und als **schlimmer** angesehen wird als Code-Duplizierung [11, 24, 25]. * Ausnahmen sind interne Konzepte wie Logging-Bibliotheken, die geteilt werden können, da sie für die Außenwelt unsichtbar sind [24]. Zusammenfassend ist Duplizierung das Signal für die **Notwendigkeit einer Design-Investition** [3], deren Beseitigung zu einem Design führt, das besser an die aktuellen Anforderungen angepasst ist [12, 26].